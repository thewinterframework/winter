package com.thewinterframework.plugin.module;

import com.google.inject.Module;
import com.thewinterframework.plugin.WinterPlugin;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jgrapht.Graph;
import org.jgrapht.alg.cycle.CycleDetector;
import org.jgrapht.graph.DefaultDirectedGraph;
import org.jgrapht.graph.DefaultEdge;
import org.jgrapht.traverse.TopologicalOrderIterator;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

/**
 * <p> This class is responsible for scanning, registering, loading, enabling, and disabling plugin modules. </p>
 */
public class PluginModuleManager implements Iterable<Class<? extends PluginModule>> {

	private final WinterPlugin plugin;
	private final Map<Class<? extends PluginModule>, PluginModule> registeredModules;
	private final Graph<Class<? extends PluginModule>, DefaultEdge> moduleGraph;
	private boolean alreadyLoaded;

	public PluginModuleManager(WinterPlugin plugin) {
		this.plugin = plugin;
		this.registeredModules = new HashMap<>();
		this.moduleGraph = new DefaultDirectedGraph<>(DefaultEdge.class);
	}

	/**
	 * Scans the modules for the plugin.
	 *
	 * @return {@code true} if the modules were scanned successfully, {@code false} otherwise.
	 */
	public boolean scanModules() {
		if (alreadyLoaded) {
			return false;
		}

		try {
			final var providers = AutoGeneratedModuleProvider.scan(plugin.getClass());
			for (final var provider : providers) {
				if (!registerModule(provider.getModuleClass())) {
					plugin.getSLF4JLogger().error("Failed to register module {}", provider.getModuleClass().getCanonicalName());
					return false;
				}
			}

			plugin.getSLF4JLogger().info("Scanned {} modules", providers.size());
			return true;
		} catch (Exception e) {
			plugin.getSLF4JLogger().error("Failed to scan modules", e);
			return false;
		}
	}

	/**
	 * Registers the given module.
	 *
	 * @param module the module to register.
	 * @return {@code true} if the module was registered successfully, {@code false} otherwise.
	 */
	public boolean registerModule(final Class<? extends PluginModule> module) {
		if (alreadyLoaded) {
			return false;
		}

		var registeredModule = registeredModules.get(module);
		if (registeredModule == null) {
			registeredModule = createInstance(module);
			if (registeredModule == null) {
				return false;
			}

			registeredModules.put(module, registeredModule);
			moduleGraph.addVertex(module);
		}

		for (final var dependency : registeredModule.depends(plugin)) {
			if (!registerModule(dependency)) {
				plugin.getSLF4JLogger().error("Failed to register dependency {} for module {}", dependency.getCanonicalName(), module.getCanonicalName());
				return false;
			}

			moduleGraph.addEdge(registeredModule.getClass(), dependency);
		}

		return true;
	}

	/**
	 * Loads the registered modules.
	 *
	 * @return {@code true} if the modules were loaded successfully, {@code false} otherwise.
	 */
	public boolean loadModules() {
		final var start = System.currentTimeMillis();
		final var cycleDetector = new CycleDetector<>(moduleGraph);
		if (cycleDetector.detectCycles()) {
			cycleDetector.findCycles()
					.forEach(cycle -> plugin.getSLF4JLogger().error("Module Cycle detected: {}", cycle.getCanonicalName()));
			return false;
		}

		final var iterator = new TopologicalOrderIterator<>(moduleGraph);
		while (iterator.hasNext()) {
			final var moduleClass = iterator.next();
			final var module = registeredModules.get(moduleClass);
			if (module == null) {
				plugin.getSLF4JLogger().error("[LOAD PHASE] Module {} not found", moduleClass.getCanonicalName());
				return false;
			}

			if (!module.onLoad(plugin)) {
				plugin.getSLF4JLogger().error("Failed to load module {}", moduleClass.getCanonicalName());
				return false;
			}

			plugin.getSLF4JLogger().info("Module '{}' loaded", moduleClass.getSimpleName());
		}

		alreadyLoaded = true;
		plugin.getSLF4JLogger().info("Loaded modules in {}ms", System.currentTimeMillis() - start);
		return true;
	}

	/**
	 * Injects the modules.
	 *
	 * @return {@code true} if the modules were injected successfully, {@code false} otherwise.
	 */
	public boolean injectModules() {
		if (!alreadyLoaded) {
			return false;
		}

		final var start = System.currentTimeMillis();
		final var iterator = new TopologicalOrderIterator<>(moduleGraph);
		while (iterator.hasNext()) {
			final var moduleClass = iterator.next();
			final var module = registeredModules.get(moduleClass);
			if (module == null) {
				plugin.getSLF4JLogger().error("[INJECTION PHASE] Module {} not found", moduleClass.getCanonicalName());
				return false;
			}

			plugin.getInjector().injectMembers(module);
		}

		plugin.getSLF4JLogger().info("Injected modules in {}ms", System.currentTimeMillis() - start);
		return true;
	}

	/**
	 * Enables the modules.
	 *
	 * @return {@code true} if the modules were enabled successfully, {@code false} otherwise.
	 */
	public boolean enableModules() {
		if (!alreadyLoaded) {
			return false;
		}

		final var start = System.currentTimeMillis();
		final var iterator = new TopologicalOrderIterator<>(moduleGraph);
		while (iterator.hasNext()) {
			final var moduleClass = iterator.next();
			final var module = registeredModules.get(moduleClass);
			if (module == null) {
				plugin.getSLF4JLogger().error("[ENABLE PHASE] Module {} not found", moduleClass.getCanonicalName());
				return false;
			}

			if (!module.onEnable(plugin)) {
				plugin.getSLF4JLogger().error("Failed to enable module {}", moduleClass.getCanonicalName());
				return false;
			}

			plugin.getSLF4JLogger().info("Module '{}' enabled", moduleClass.getSimpleName());
		}

		plugin.getSLF4JLogger().info("Enabled modules in {}ms", System.currentTimeMillis() - start);
		return true;
	}

	/**
	 * Disables the modules.
	 *
	 * @return {@code true} if the modules were disabled successfully, {@code false} otherwise.
	 */
	public boolean disableModules() {
		if (!alreadyLoaded) {
			return false;
		}

		final var start = System.currentTimeMillis();
		final var iterator = new TopologicalOrderIterator<>(moduleGraph);
		while (iterator.hasNext()) {
			final var moduleClass = iterator.next();
			final var module = registeredModules.get(moduleClass);
			if (module == null) {
				plugin.getSLF4JLogger().error("[DISABLE PHASE] Module {} not found", moduleClass.getCanonicalName());
				return false;
			}

			if (!module.onDisable(plugin)) {
				plugin.getSLF4JLogger().error("Failed to disable module {}", moduleClass.getCanonicalName());
				return false;
			}

			plugin.getSLF4JLogger().info("Module '{}' disabled", moduleClass.getSimpleName());
		}

		plugin.getSLF4JLogger().info("Disabled modules in {}ms", System.currentTimeMillis() - start);

		return true;
	}

	/**
	 * Checks if the given module is registered.
	 *
	 * @param clazz the module class to check.
	 * @return {@code true} if the module is registered, {@code false} otherwise.
	 */
	public boolean isRegistered(Class<? extends PluginModule> clazz) {
		return registeredModules.containsKey(clazz);
	}

	/**
	 * Gets the module of the given class.
	 *
	 * @param clazz the module class to get.
	 * @param <T>   the type of the module.
	 * @return the module of the given class, or {@code null} if the module is not registered.
	 */
	@Nullable
	public <T extends PluginModule> T getModule(Class<T> clazz) {
		return clazz.cast(registeredModules.get(clazz));
	}

	/**
	 * Gets the registered modules.
	 * @return the registered modules.
	 */
	public Set<Module> asGuiceModules() {
		return Set.copyOf(registeredModules.values());
	}

	@NotNull
	@Override
	public Iterator<Class<? extends PluginModule>> iterator() {
		return new TopologicalOrderIterator<>(moduleGraph);
	}

	/**
	 * Creates an instance of the given class.
	 *
	 * @param clazz the class to create an instance of.
	 * @param <T>   the type of the class.
	 * @return an instance of the given class.
	 */
	private <T> T createInstance(Class<T> clazz) {
		try {
			return clazz.getDeclaredConstructor().newInstance();
		} catch (Exception e) {
			plugin.getSLF4JLogger().error("Failed to create instance of module {}", clazz.getName(), e);
			return null;
		}
	}
}
