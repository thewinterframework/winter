package com.thewinterframework.plugin.module;

import com.google.inject.Module;
import com.thewinterframework.plugin.WinterPlugin;
import com.thewinterframework.utils.graph.DfsGraph;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

/**
 * <p> This class is responsible for scanning, registering, loading, enabling, and disabling plugin modules. </p>
 */
public class PluginModuleManager implements Iterable<Class<? extends PluginModule>> {

	private final WinterPlugin plugin;
	private final Logger logger;
	
	private final Map<Class<? extends PluginModule>, PluginModule> registeredModules;
	private final DfsGraph<Class<? extends PluginModule>> moduleGraph;
	
	private boolean alreadyLoaded;

	public PluginModuleManager(WinterPlugin plugin) {
		this.plugin = plugin;
		this.logger = plugin.getSLF4JLogger();
		this.registeredModules = new HashMap<>();
		this.moduleGraph = new DfsGraph<>();
	}

	/**
	 * Scans the modules for the plugin.
	 *
	 * @return {@code true} if the modules were scanned successfully, {@code false} otherwise.
	 */
	public boolean scanModules() {
		if (alreadyLoaded) {
			return false;
		}

		try {
			final var providers = AutoGeneratedModuleProvider.scan(plugin.getClass());
			for (final var provider : providers) {
				if (!registerModule(provider.getModuleClass())) {
					logger.error("Failed to register module {}", provider.getModuleClass().getCanonicalName());
					return false;
				}
			}

			logger.info("Scanned {} modules", providers.size());
			return true;
		} catch (Exception e) {
			logger.error("Failed to scan modules", e);
			return false;
		}
	}

	/**
	 * Registers the given module.
	 *
	 * @param module the module to register.
	 * @return {@code true} if the module was registered successfully, {@code false} otherwise.
	 */
	public boolean registerModule(final Class<? extends PluginModule> module) {
		if (alreadyLoaded) {
			return false;
		}

		var registeredModule = registeredModules.get(module);
		if (registeredModule == null) {
			registeredModule = createInstance(module);
			if (registeredModule == null) {
				return false;
			}

			registeredModules.put(module, registeredModule);
			moduleGraph.addNode(module);
		}

		for (final var dependency : registeredModule.depends(plugin)) {
			if (!registerModule(dependency)) {
				logger.error("Failed to register dependency {} for module {}", dependency.getCanonicalName(), module.getCanonicalName());
				return false;
			}

			moduleGraph.addAfter(module, dependency);
		}

		for (final var before : registeredModule.before(plugin)) {
			if (!registerModule(before)) {
				logger.error("Failed to register module {} before module {}", before.getCanonicalName(), module.getCanonicalName());
				return false;
			}

			moduleGraph.addBefore(before, module);
		}

		return true;
	}

	/**
	 * Loads the registered modules.
	 *
	 * @return {@code true} if the modules were loaded successfully, {@code false} otherwise.
	 */
	public boolean loadModules() {
		final var start = System.currentTimeMillis();
		for (final var moduleClass : moduleGraph) {
			final var module = registeredModules.get(moduleClass);
			if (module == null) {
				logger.error("[LOAD PHASE] Module {} not found", moduleClass.getCanonicalName());
				return false;
			}

			if (!module.onLoad(plugin)) {
				logger.error("Failed to load module {}", moduleClass.getCanonicalName());
				return false;
			}

			logger.info("Module '{}' loaded", moduleClass.getSimpleName());
		}

		alreadyLoaded = true;
		logger.info("Loaded modules in {}ms", System.currentTimeMillis() - start);
		return true;
	}

	/**
	 * Injects the modules.
	 *
	 * @return {@code true} if the modules were injected successfully, {@code false} otherwise.
	 */
	public boolean injectModules() {
		if (!alreadyLoaded) {
			return false;
		}

		final var start = System.currentTimeMillis();
		for (final var moduleClass : moduleGraph) {
			final var module = registeredModules.get(moduleClass);
			if (module == null) {
				logger.error("[INJECTION PHASE] Module {} not found", moduleClass.getCanonicalName());
				return false;
			}

			plugin.getInjector().injectMembers(module);
		}

		logger.info("Injected modules in {}ms", System.currentTimeMillis() - start);
		return true;
	}

	/**
	 * Enables the modules.
	 *
	 * @return {@code true} if the modules were enabled successfully, {@code false} otherwise.
	 */
	public boolean enableModules() {
		if (!alreadyLoaded) {
			return false;
		}

		final var start = System.currentTimeMillis();
		for (final var moduleClass : moduleGraph) {
			final var module = registeredModules.get(moduleClass);
			if (module == null) {
				logger.error("[ENABLE PHASE] Module {} not found", moduleClass.getCanonicalName());
				return false;
			}

			if (!module.onEnable(plugin)) {
				logger.error("Failed to enable module {}", moduleClass.getCanonicalName());
				return false;
			}

			logger.info("Module '{}' enabled", moduleClass.getSimpleName());
		}

		logger.info("Enabled modules in {}ms", System.currentTimeMillis() - start);
		return true;
	}

	/**
	 * Disables the modules.
	 *
	 * @return {@code true} if the modules were disabled successfully, {@code false} otherwise.
	 */
	public boolean disableModules() {
		if (!alreadyLoaded) {
			return false;
		}

		final var start = System.currentTimeMillis();
		for (final var moduleClass : moduleGraph) {
			final var module = registeredModules.get(moduleClass);
			if (module == null) {
				logger.error("[DISABLE PHASE] Module {} not found", moduleClass.getCanonicalName());
				return false;
			}

			if (!module.onDisable(plugin)) {
				logger.error("Failed to disable module {}", moduleClass.getCanonicalName());
				return false;
			}

			logger.info("Module '{}' disabled", moduleClass.getSimpleName());
		}

		logger.info("Disabled modules in {}ms", System.currentTimeMillis() - start);

		return true;
	}

	/**
	 * Checks if the given module is registered.
	 *
	 * @param clazz the module class to check.
	 * @return {@code true} if the module is registered, {@code false} otherwise.
	 */
	public boolean isRegistered(final Class<? extends PluginModule> clazz) {
		return registeredModules.containsKey(clazz);
	}

	/**
	 * Gets the module of the given class.
	 *
	 * @param clazz the module class to get.
	 * @param <T>   the type of the module.
	 * @return the module of the given class, or {@code null} if the module is not registered.
	 */
	@Nullable
	public <T extends PluginModule> T getModule(final Class<T> clazz) {
		return clazz.cast(registeredModules.get(clazz));
	}

	/**
	 * Gets the registered modules.
	 * @return the registered modules.
	 */
	public Set<Module> asGuiceModules() {
		return Set.copyOf(registeredModules.values());
	}

	@NotNull
	@Override
	public Iterator<Class<? extends PluginModule>> iterator() {
		return moduleGraph.iterator();
	}

	/**
	 * Creates an instance of the given class.
	 *
	 * @param clazz the class to create an instance of.
	 * @param <T>   the type of the class.
	 * @return an instance of the given class.
	 */
	private <T> T createInstance(final Class<T> clazz) {
		try {
			return clazz.getDeclaredConstructor().newInstance();
		} catch (Exception e) {
			logger.error("Failed to create instance of module {}", clazz.getName(), e);
			return null;
		}
	}
}
