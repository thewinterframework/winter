package com.thewinterframework.plugin.module;

import com.google.inject.Module;
import com.thewinterframework.plugin.WinterPlugin;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jgrapht.Graph;
import org.jgrapht.alg.cycle.CycleDetector;
import org.jgrapht.graph.DefaultDirectedGraph;
import org.jgrapht.graph.DefaultEdge;
import org.jgrapht.traverse.TopologicalOrderIterator;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public class PluginModuleManager implements Iterable<Class<? extends PluginModule>> {

	private final WinterPlugin plugin;
	private final Map<Class<? extends PluginModule>, PluginModule> registeredModules;
	private final Graph<Class<? extends PluginModule>, DefaultEdge> moduleGraph;
	private boolean alreadyLoaded;

	public PluginModuleManager(WinterPlugin plugin) {
		this.plugin = plugin;
		this.registeredModules = new HashMap<>();
		this.moduleGraph = new DefaultDirectedGraph<>(DefaultEdge.class);
	}

	public boolean scanModules() {
		if (alreadyLoaded) {
			return false;
		}

		try {
			final var providers = AutoGeneratedModuleProvider.scan(plugin.getClass());
			for (final var provider : providers) {
				if (!registerModule(provider.getModuleClass())) {
					plugin.getSLF4JLogger().error("Failed to register module {}", provider.getModuleClass().getCanonicalName());
					return false;
				}
			}

			plugin.getSLF4JLogger().info("Scanned {} modules", providers.size());
			return true;
		} catch (Exception e) {
			plugin.getSLF4JLogger().error("Failed to scan modules", e);
			return false;
		}
	}

	public boolean registerModule(final Class<? extends PluginModule> module) {
		if (alreadyLoaded) {
			return false;
		}

		var registeredModule = registeredModules.get(module);
		if (registeredModule == null) {
			registeredModule = createInstance(module);
			if (registeredModule == null) {
				return false;
			}

			registeredModules.put(module, registeredModule);
			moduleGraph.addVertex(module);
		}

		for (final var dependency : registeredModule.depends(plugin)) {
			if (!registerModule(dependency)) {
				plugin.getSLF4JLogger().error("Failed to register dependency {} for module {}", dependency.getCanonicalName(), module.getCanonicalName());
				return false;
			}

			moduleGraph.addEdge(registeredModule.getClass(), dependency);
		}

		return true;
	}

	public boolean loadModules() {
		final var start = System.currentTimeMillis();
		final var cycleDetector = new CycleDetector<>(moduleGraph);
		if (cycleDetector.detectCycles()) {
			cycleDetector.findCycles()
					.forEach(cycle -> plugin.getSLF4JLogger().error("Module Cycle detected: {}", cycle.getCanonicalName()));
			return false;
		}

		final var iterator = new TopologicalOrderIterator<>(moduleGraph);
		while (iterator.hasNext()) {
			final var moduleClass = iterator.next();
			final var module = registeredModules.get(moduleClass);
			if (module == null) {
				plugin.getSLF4JLogger().error("[LOAD PHASE] Module {} not found", moduleClass.getCanonicalName());
				return false;
			}

			if (!module.onLoad(plugin)) {
				plugin.getSLF4JLogger().error("Failed to load module {}", moduleClass.getCanonicalName());
				return false;
			}

			plugin.getSLF4JLogger().info("Module '{}' loaded", moduleClass.getSimpleName());
		}

		alreadyLoaded = true;
		plugin.getSLF4JLogger().info("Loaded modules in {}ms", System.currentTimeMillis() - start);
		return true;
	}

	public boolean injectModules() {
		if (!alreadyLoaded) {
			return false;
		}

		final var start = System.currentTimeMillis();
		final var iterator = new TopologicalOrderIterator<>(moduleGraph);
		while (iterator.hasNext()) {
			final var moduleClass = iterator.next();
			final var module = registeredModules.get(moduleClass);
			if (module == null) {
				plugin.getSLF4JLogger().error("[INJECTION PHASE] Module {} not found", moduleClass.getCanonicalName());
				return false;
			}

			plugin.getInjector().injectMembers(module);
		}

		plugin.getSLF4JLogger().info("Injected modules in {}ms", System.currentTimeMillis() - start);
		return true;
	}

	public boolean enableModules() {
		if (!alreadyLoaded) {
			return false;
		}

		final var start = System.currentTimeMillis();
		final var iterator = new TopologicalOrderIterator<>(moduleGraph);
		while (iterator.hasNext()) {
			final var moduleClass = iterator.next();
			final var module = registeredModules.get(moduleClass);
			if (module == null) {
				plugin.getSLF4JLogger().error("[ENABLE PHASE] Module {} not found", moduleClass.getCanonicalName());
				return false;
			}

			if (!module.onEnable(plugin)) {
				plugin.getSLF4JLogger().error("Failed to enable module {}", moduleClass.getCanonicalName());
				return false;
			}

			plugin.getSLF4JLogger().info("Module '{}' enabled", moduleClass.getSimpleName());
		}

		plugin.getSLF4JLogger().info("Enabled modules in {}ms", System.currentTimeMillis() - start);
		return true;
	}

	public boolean disableModules() {
		if (!alreadyLoaded) {
			return false;
		}

		final var start = System.currentTimeMillis();
		final var iterator = new TopologicalOrderIterator<>(moduleGraph);
		while (iterator.hasNext()) {
			final var moduleClass = iterator.next();
			final var module = registeredModules.get(moduleClass);
			if (module == null) {
				plugin.getSLF4JLogger().error("[DISABLE PHASE] Module {} not found", moduleClass.getCanonicalName());
				return false;
			}

			if (!module.onDisable(plugin)) {
				plugin.getSLF4JLogger().error("Failed to disable module {}", moduleClass.getCanonicalName());
				return false;
			}

			plugin.getSLF4JLogger().info("Module '{}' disabled", moduleClass.getSimpleName());
		}

		plugin.getSLF4JLogger().info("Disabled modules in {}ms", System.currentTimeMillis() - start);

		return true;
	}

	public boolean isRegistered(Class<? extends PluginModule> clazz) {
		return registeredModules.containsKey(clazz);
	}

	@Nullable
	public <T extends PluginModule> T getModule(Class<T> clazz) {
		return clazz.cast(registeredModules.get(clazz));
	}

	public Set<Module> asGuiceModules() {
		return Set.copyOf(registeredModules.values());
	}

	@NotNull
	@Override
	public Iterator<Class<? extends PluginModule>> iterator() {
		return new TopologicalOrderIterator<>(moduleGraph);
	}

	private <T> T createInstance(Class<T> clazz) {
		try {
			return clazz.getDeclaredConstructor().newInstance();
		} catch (Exception e) {
			plugin.getSLF4JLogger().error("Failed to create instance of module {}", clazz.getName(), e);
			return null;
		}
	}
}
