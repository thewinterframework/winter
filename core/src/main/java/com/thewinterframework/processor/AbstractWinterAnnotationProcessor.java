package com.thewinterframework.processor;

import com.thewinterframework.plugin.WinterBootPlugin;
import com.thewinterframework.plugin.WinterPlugin;
import com.thewinterframework.plugin.module.PluginModule;
import com.thewinterframework.utils.Tuple;
import org.jetbrains.annotations.ApiStatus;
import org.jetbrains.annotations.Nullable;

import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.Name;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.Elements;
import javax.tools.Diagnostic;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.lang.annotation.Annotation;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.function.BiConsumer;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Abstract class for Winter annotation processors.
 */
public abstract class AbstractWinterAnnotationProcessor extends AbstractProcessor {

	private final static String WINTER_MODULE_PACKAGE_PREFIX = ".autogenerated_winter_modules";
	private final static String AUTOGENERATED_MODULE_PROVIDER_TEMPLATE = "generated/AutoGeneratedModuleProviderTemplate.java";

	private Element pluginClass;

	@Override
	public final boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
		if (pluginClass == null) {
			pluginClass = roundEnv.getElementsAnnotatedWith(WinterBootPlugin.class).stream()
					.filter(this::isClass)
					.findFirst()
					.orElseThrow(() -> new IllegalStateException(WinterBootPlugin.class.getCanonicalName() + " annotation not found in the project!"));
		}

		final var filteredAnnotations = annotations.stream()
				.filter(annotation -> !equals(annotation, WinterBootPlugin.class)) // Filter out the WinterBootPlugin annotation
				.collect(Collectors.toSet());

		if (filteredAnnotations.isEmpty()) {
			return false;
		}

		final var requiredModule = requiredModule();
		final var requiredCanonicalModuleName = requiredCanonicalModuleName();
		if (requiredModule != null) {
			copyTemplate(AUTOGENERATED_MODULE_PROVIDER_TEMPLATE, getNewModuleProviderPath(requiredModule), (reader, writer) -> {
				final var var = List.of(
						new Tuple<>("<PACKAGE_NAME>", getAutoGeneratedModulesPackage()),
						new Tuple<>("<MODULE>", requiredModule.getSimpleName()),
						new Tuple<>("<SCANNED_CLASS>", asClassString(asElement(requiredModule)))
				);

				pathReader(reader, var).forEach(writer::println);
			});
		}

		if (requiredCanonicalModuleName != null) {
			copyTemplate(AUTOGENERATED_MODULE_PROVIDER_TEMPLATE, getNewModuleProviderPath(requiredCanonicalModuleName), (reader, writer) -> {
						final var var = List.of(
								new Tuple<>("<PACKAGE_NAME>", getAutoGeneratedModulesPackage()),
								new Tuple<>("<MODULE>", getSimpleNameFromCanonicalName(requiredCanonicalModuleName)),
								new Tuple<>("<SCANNED_CLASS>", asClassString(requiredCanonicalModuleName))
						);

						pathReader(reader, var).forEach(writer::println);
			});
		}

		return process(pluginClass, filteredAnnotations, roundEnv);
	}

	/**
	 * Processes the plugin class.
	 * @param pluginClass The plugin class.
	 * @param annotations The annotations.
	 * @param roundEnv The round environment.
	 * @return Whether the set of annotation interfaces are claimed by this processor
	 */
	protected abstract boolean process(Element pluginClass, Set<? extends TypeElement> annotations, RoundEnvironment roundEnv);

	/**
	 * Returns the module class required by the plugin.
	 * @return The module class which will be registered by the plugin.
	 */
	protected @Nullable Class<? extends PluginModule> requiredModule() {
		return null;
	}

	/**
	 * Returns the canonical name of the required module.
	 * @return The canonical name of the required module.
	 */
	protected @Nullable String requiredCanonicalModuleName() {
		return null;
	}

	@Override
	public final Set<String> getSupportedAnnotationTypes() {
		final var annotations = new HashSet<>(getSupportedAnnotations());
		annotations.add(WinterBootPlugin.class);

		return annotations.stream()
				.map(Class::getCanonicalName)
				.collect(Collectors.toSet());
	}

	/**
	 * Returns the supported annotations.
	 * @return The supported annotations.
	 */
	protected abstract Set<Class<? extends Annotation>> getSupportedAnnotations();

	@Override
	public SourceVersion getSupportedSourceVersion() {
		return SourceVersion.latestSupported();
	}

	protected final boolean isClass(Element element) {
		return element.getKind() == ElementKind.CLASS;
	}

	protected final boolean isRecord(Element element) {
		return element.getKind() == ElementKind.RECORD;
	}

	protected final boolean isField(Element element) {
		return element.getKind() == ElementKind.FIELD || element.getKind() == ElementKind.PARAMETER;
	}

	/**
	 * Gets the package of the auto-generated modules.
	 * @return The package of the auto-generated modules.
	 */
	protected final String getAutoGeneratedModulesPackage() {
		return getPluginPackage() + WINTER_MODULE_PACKAGE_PREFIX;
	}

	/**
	 * Gets the package of the auto-generated modules.
	 * @param pluginClass The plugin class.
	 * @return The package of the auto-generated modules.
	 */
	public static String getAutoGeneratedModulesPackage(Class<? extends WinterPlugin> pluginClass) {
		return pluginClass.getPackageName() + WINTER_MODULE_PACKAGE_PREFIX;
	}

	/**
	 * Gets the package of the auto-generated modules.
	 * @param moduleClass The module class.
	 * @return The package of the auto-generated modules.
	 */
	protected final String getNewModuleProviderPath(Class<? extends PluginModule> moduleClass) {
		return getAutoGeneratedModulesPackage() + "." + moduleClass.getSimpleName() + "Provider";
	}

	/**
	 * Gets the package of the auto-generated modules.
	 * @param moduleClassCanonicalName The module class canonical name.
	 * @return The package of the auto-generated modules.
	 */
	protected final String getNewModuleProviderPath(String moduleClassCanonicalName) {
		return getAutoGeneratedModulesPackage() + "." + getSimpleNameFromCanonicalName(moduleClassCanonicalName) + "Provider";
	}

	/**
	 * Gets the package of the plugin.
	 * @return The package of the plugin.
	 */
	protected final String getPluginPackage() {
		return elementUtils().getPackageOf(pluginClass).getQualifiedName().toString();
	}

	/**
	 * Gets the simple name from the canonical name.
	 * @param canonicalName The canonical name.
	 * @return The simple name.
	 */
	protected final String getSimpleNameFromCanonicalName(String canonicalName) {
		return canonicalName.substring(canonicalName.lastIndexOf('.') + 1);
	}

	protected final boolean equals(TypeElement element, Class<?> clazz) {
		return element.getQualifiedName().contentEquals(clazz.getCanonicalName());
	}

	protected final Messager messager() {
		return processingEnv.getMessager();
	}

	protected final String asClassString(Element element) {
		return element.asType().toString() + ".class";
	}

	protected final String asClassString(String canonicalName) {
		return canonicalName + ".class";
	}

	protected final Element asElement(Class<?> type) {
		return elementUtils().getTypeElement(type.getCanonicalName());
	}

	protected final boolean isChild(TypeMirror child, String rootQualifiedName) {
		final var childType = (DeclaredType) child;
		final var childElement = (TypeElement) childType.asElement();

		return childElement.getInterfaces().stream()
				.map(interfaces -> (DeclaredType) interfaces)
				.map(DeclaredType::asElement)
				.map(TypeElement.class::cast)
				.map(TypeElement::getQualifiedName)
				.map(Name::toString)
				.anyMatch(name -> name.equals(rootQualifiedName));
	}

	protected final boolean isChild(TypeMirror child, TypeMirror root) {
		final var rootType = (DeclaredType) root;
		final var rootElement = (TypeElement) rootType.asElement();
		final var rootQualifiedName = rootElement.getQualifiedName().toString();

		return isChild(child, rootQualifiedName);
	}

	protected final Filer filer() {
		return processingEnv.getFiler();
	}

	protected final Elements elementUtils() {
		return processingEnv.getElementUtils();
	}

	/**
	 * Copies the template.
	 * @param template The template.
	 * @param newName The new name.
	 * @param actions The actions.
	 */
	protected void copyTemplate(String template, String newName, BiConsumer<BufferedReader, PrintWriter> actions) {
		try (var templateStream = getClass().getClassLoader().getResourceAsStream(template)) {
			if (templateStream == null) {
				throw new IllegalArgumentException("Template " + template + " not found");
			}

			try (var reader = new BufferedReader(new InputStreamReader(templateStream))) {
				try (var writer = new PrintWriter(filer().createSourceFile(newName).openWriter())) {
					actions.accept(reader, writer);
				} catch (FilerException e) {
					messager().printMessage(Diagnostic.Kind.NOTE, "File already exists: " + newName);
				}
			}
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
	}

	protected Stream<String> pathReader(BufferedReader reader, List<Tuple<String, String>> var) {
		return reader.lines()
				.map(line -> {
					for (Tuple<String, String> tuple : var) {
						line = line.replace(tuple.first(), tuple.second());
					}
					return line;
				});
	}

}
