package com.thewinterframework.configurate.config;

import com.thewinterframework.configurate.module.ConfigurateModule;
import com.thewinterframework.plugin.module.PluginModule;
import com.thewinterframework.processor.AbstractWinterAnnotationProcessor;
import org.jetbrains.annotations.Nullable;

import javax.annotation.processing.RoundEnvironment;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import java.lang.annotation.Annotation;
import java.util.HashSet;
import java.util.Set;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

public class ConfigurateAnnotationProcessor extends AbstractWinterAnnotationProcessor {

	public static final Pattern ELEMENT_PATTERN = Pattern.compile("(?:<el>)([\\s\\S]*)(?:<\\/el>)");

	@Override
	protected @Nullable Class<? extends PluginModule> requiredModule() {
		return ConfigurateModule.class;
	}

	@Override
	protected @Nullable String requiredCanonicalModuleName() {
		return getModulePackage() + ".ConfigurationsModule";
	}

	@Override
	protected void process(Element pluginClass, Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
		for (final var parent : annotations) {
			copyTemplate("generated/AutoGeneratedConfigurateModule.java", getModulePackage() + "." + "ConfigurationsModule", (reader, writer) -> {
				final var content = reader.lines()
						.collect(Collectors.joining(System.lineSeparator()));

				final var matcher = ELEMENT_PATTERN.matcher(
						replaceVariables(content, commonVariables())
				);

				final var alreadyWritten = new HashSet<String>();

				final var buffer = new StringBuffer();
				while (matcher.find()) {
					final var builder = new StringBuilder();
					for (final var element : roundEnv.getElementsAnnotatedWith(parent)) {
						System.out.println(element);
						if (!isClass(element) && !isRecord(element)) {
							System.out.println(element + " is not a class");
							continue;
						}

						final var annotation = element.getAnnotation(Configurate.class);
						if (annotation == null) {
							System.out.println(element + " is not annotated with @Configurate or @ConfigSerializable");
							continue;
						}

						final var fileName = annotation.value();
						if (alreadyWritten.contains(fileName)) {
							continue;
						}

						builder.append(
								replaceVariables(
										matcher.group(1),
										TemplateVar.create("CONFIG_NAME", fileName),
										TemplateVar.create("CONFIG_OBJECT", element)
								)
						).append(System.lineSeparator());

						alreadyWritten.add(fileName);
					}

					matcher.appendReplacement(buffer, builder.toString());
				}

				matcher.appendTail(buffer);
				writer.println(buffer);
			});
		}
	}

	private TemplateVar[] commonVariables() {
		return new TemplateVar[]{
				TemplateVar.create("PACKAGE_NAME", getModulePackage()),
				TemplateVar.create("CLASS_NAME", "ConfigurationsModule"),
		};
	}

	public String getModulePackage() {
		return getPluginPackage() + ".autogenerated_winter_config_module";
	}

	protected String replaceVariables(String line, TemplateVar... variables) {
		for (var variable : variables) {
			line = line.replace(variable.variable(), variable.value().toString());
		}

		return line;
	}

	public record TemplateVar(
			String variable,
			Object value
	) {

		public static TemplateVar create(String variable, Object value) {
			return new TemplateVar("<" + variable + ">", value);
		}

	}

	@Override
	protected Set<Class<? extends Annotation>> getSupportedAnnotations() {
		return Set.of(Configurate.class);
	}
}
